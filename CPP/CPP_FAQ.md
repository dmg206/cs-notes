### 变量的声明和定义有什么区别

> 为变量分配地址和存储空间的称为定义, 不分配地址的称为声明; 一个变量可以在多个地方声明, 但是只在一个地方定义;
> 加入extern修饰的是变量的声明, 说明此变量将在文件以外或在文件后面部分定义; 说明: 很多时候一个变量, 只是声明不分配内存空间, 直到具体使用时才初始化, 分配内存空间,如外部变量;

### 简述C, C++程序编译的内存分配情况

> C, C++中内存分配方式可以分为三种:

1. 从静态存储区域分配: 内存在程序编译时就已经分配好, 这块内存在程序的整个运行期间都存在; 速度快, 不容易出错, 因为有系统会善后; 例如全局变量, static变量等;
2. 在栈上分配: 在执行函数时, 函数内局部变量的存储单元都在栈上创建, 函数执行结束时这些存储单元自动被释放;栈内存分配运算内置于处理器的指令集中, 效率很高, 但是分配的内存容量有限;
3. 从堆上分配: 即动态内存分配; 程序在运行的时候用malloc或new申请任意大小的内存, 程序员自己负责在何时用free或delete释放内存; 动态内存的生存期由程序员决定, 使用非常灵活; 如果在堆上分配了空间, 就有责任回收它, 否则运行的程序会出现内存泄漏, 另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块;

> C, C++程序编译时内存分为5大存储区: 堆区, 栈区, 全局区, 文字常量区, 程序代码区



### 谈谈你对拷贝构造函数和赋值运算符的认识

> 拷贝构造函数和赋值运算符重载有以下两个不同之处:

1. 拷贝构造函数生成新的类对象,而赋值运算符不能;
2. 由于拷贝构造函数是直接构造一个新的类对象, 所以在初始化这个对象之前不用检验源对象是否和新建对象相同;而赋值运算符则需要这个操作, 另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉

### 简述多态实现的原理

> 编译器发现一个类中有虚函数, 便会立即为此类生成虚函数表 vtable;
> 虚函数表的各表项为指向对应虚函数的指针; 编译器还会在此类中隐含插入一个指针vptr(对vc编译器来说, 它插在类的第一个位置上)指向虚函数表; 调用此类的构造函数时, 在类的构造函数中, 编译器会隐含执行vptr与vtable的关联代码, 将vptr指向对应的vtable, 将类与此类的vtable联系了起来;
> 另外在调用类的构造函数时, 指向基础类的指针此时已经变成指向具体的类的this指针, 这样依靠此this指针即可得到正确的vtable; 如此才能真正与函数体进行连接, 这就是动态联编,实现多态的基本原理; 注意: 一定要区分虚函数,纯虚函数, 虚拟继承的关系和区别;牢记虚函数实现原理, 因为多态C++面试的重要考点之一 , 而虚函数是实现多态的基础;

### extern有什么作用

> extern标识的变量或者函数声明其定义在别的文件中, 提示编译器遇到此变量和函数时在其它模块中寻找其定义;



### 构造函数能否为虚函数

> 构造函数不能是虚函数; 而且不能在构造函数中调用虚函数, 因为那样实际执行的是父类的对应函数, 因为自己还没有构造好; 析构函数可以是虚函数, 而且在一个复杂类结构中, 这往往是必须的; 析构函数也可以是纯虚函数, 但纯虚析构函数必须有定义体, 因为析构函数的调用是在子类中隐含的;
>
> > 说明: 虚函数的动态绑定特性是实现重载的关键技术, 动态绑定根据实际的调用情况查询相应类的虚函数表, 调用相应的虚函数;



### new malloc delete free 区别

1. delete 用于释放 new 分配的空间; free 用来释放 malloc 分配的空间;
2. delete[] 用于释放 new[] 分配的空间;
3. delete 释放空间的时候会调用相应的析构函数, 同时new时调用构造函数, 而malloc不会, 它只是分配内存;
4. 调用free 之前需要检查 需要释放的指针是否为空，使用delete 释放内存则不需要检查指针是否为NULL
5. malloc与free是C++/C语言的标准库函数, new/delete是C++的运算符, 它们都可用于申请动态内存和释放内存;

> 对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。